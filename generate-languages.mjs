import fs from "fs/promises";
import path from "path";
import { isBinary } from "istextorbinary";

const languagesDirPath = path.resolve("languages");
const outputFilePath = path.resolve("client", "src", "data", "languages.ts");

function processFileName(rawFileName) {
  const name = rawFileName.includes(".")
    ? rawFileName.substring(0, rawFileName.lastIndexOf("."))
    : rawFileName;

  const baseId = name
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/[^\w-]+/g, "");

  return { baseId, name };
}

async function generateLanguagesFile() {
  console.log(
    "üöÄ Starting language data generation (with proper binary file detection)..."
  );
  const languagesData = [];
  const usedIds = new Set();
  let skippedCount = 0;

  try {
    const topLevelDirs = await fs.readdir(languagesDirPath);

    for (const dir of topLevelDirs) {
      const dirPath = path.join(languagesDirPath, dir);
      if ((await fs.stat(dirPath)).isDirectory()) {
        const files = await fs.readdir(dirPath);
        for (const file of files) {
          const filePath = path.join(dirPath, file);
          const stats = await fs.stat(filePath);

          if (stats.isFile()) {
            const buffer = await fs.readFile(filePath);

            if (await isBinary(filePath, buffer)) {
              console.log(`- Skipping binary file: ${file}`);
              skippedCount++;
              continue;
            }

            const syntax = buffer.toString("utf-8");
            const { baseId, name } = processFileName(file);

            if (baseId && syntax) {
              let finalId = baseId;
              let counter = 1;
              while (usedIds.has(finalId)) {
                finalId = `${baseId}-${counter}`;
                counter++;
              }
              usedIds.add(finalId);

              languagesData.push({
                id: finalId,
                name,
                syntax: syntax.trim(),
                creator: "",
                year: 0,
                paradigm: "",
                history: "",
                purpose: "",
                facts: [],
              });
            }
          }
        }
      }
    }

    languagesData.sort((a, b) => a.name.localeCompare(b.name));

    const fileContent = `
// This file is auto-generated by generate-languages.mjs. Do not edit manually.

export interface Language {
  id: string;
  name: string;
  creator: string;
  year: number;
  paradigm: string;
  syntax: string;
  history: string;
  purpose: string;
  facts: string[];
}

export const languages: Language[] = ${JSON.stringify(languagesData, null, 2)};
`;

    await fs.writeFile(outputFilePath, fileContent.trim());
    console.log(
      `‚úÖ Success! Wrote data for ${languagesData.length} languages to ${outputFilePath}`
    );
    if (skippedCount > 0) {
      console.log(`‚ÑπÔ∏è Skipped ${skippedCount} binary files.`);
    }
  } catch (error) {
    console.error("‚ùå An error occurred:", error);
  }
}

generateLanguagesFile();
